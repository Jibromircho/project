# pongle
#### Video Demo:  <URL HERE>
#### Description: The program that i have written is a simple pong like game in python using its pygame libary for some of the built in game making functions. I have seperated the program and its classes in different files so it is structured better and its easier to read/understand and improve whenever needed. I've tried to implement comments to the best of my abilities, but some functions ended up not having any. To beggin with when we run the main program which is "pongle.py" we import all the libraries that we will ever use like pygame,time,sys,etc. and then we import all the different classes from the other files that we would use. After that we initilize the game class and in the "def __innit__(self):" we declare almost all varuables that we are going to use , as well as the window for the game, the windows caption and the game clock. After that we have a function "run_game" that we call at the end of the file, which is the main loop that we run the game from.In "run_game" we will be adding other primary functions that need to be executing all the time untill the game is running.It consist of 1-"while True" loop to make the all other functions run while the game is active,2-"_check_events", this is a function that "listens" for player inputs on the keyboard, 3-"if self.game_active", this is an if statement for if the game is currently under going or it is between player deaths, or just started the program but not initiated the gameplay yet,4-"player.update" this is a fuction which is located inside of the player class in the player.py file which updates the players location depending on what the "_check_events" function has detected as input,aka. if user is pressing arrow key left we update the player paddle to move to the left until the arrow key is being pressed,5-"_check_ball_bounce" handles all different cases where the ball needs to bounce in a different direction(when a wall is hit,when player paddle is hit or when a brick is hit),6-"ball.update" is a function thats inside of the ball class in the ball.py file which deals with where the ball needs to go and it updates the x and y coordinates of the ball accordingly, 7-"_update_screen" this deals with everything that needs to be updated to the screen for every frame the game runs, aka. anything that moves or can be different in the next frame is updated and redrawn to the screen here and finally 8-"clock.tick(60)" which is one of the pygames functions that deals with the framerate of the game, 60 being a 60 frames per seccond game.Almost all of these functions we use here have move nested fucntions inside them for a clearer code.Next in "_check_events" we have 2 different functions "_check_keydown_events" and "_check_keyup_events" one for when the user preses and holds down a key and another for when the user stops pressing down that key, this is to make sure a continues key being pressed continues to move the player paddle in a direction.Movind down the file we have a "_start_game" which initializes the dynamic settings for the game (player movement speed,brick size,ball speed and the scores the bricks give)then after that we prepare the score and the level elements that need to be displayed on screen for the user to see then we set the ball_moving to True to initialize ball movement and finally we make the mouse cursor invisible.After that we get to the "_update_screen" which line by line fills in the background colour of the game,draws the player paddle,draws the ball,draws all the score attributes,than we draw all the bricks on the screen,if the game is not active yet, but still running we draw a simple message on how to start the game, or if we have a game_active to false we draw a game over message and finally we flip to the next frame and redraw everything again and again. After that we have "_spawn_bricks" this creates bricks if the screen is not filled with them already and it calls the next function in the file "_create_bricks" that creates the individual bricks and adds them in the bricks sprite list we have for storing all the bricks, we also adjust the possition of the next brick created to be slightly on the right hand side of the previus one.After that we have the "_check_ball_bounce" that checks if the ball hit box has reached a wall and bounces it back, if it reaches the bottom it runs a "_ball_lost" that we will explore later, and then it calls "_check_player_hit" and "_check_brick_hit" which check if the player is hit or a brick is hit.After that is "_check_player_hit" which calculates where exacly on the player paddle the ball has connected and uses "_ball_speed_adjust" to adjust the ball speed acordingly so it has more accurate "physics" to hitting the ball at an angle. AFter that is "_check_brick_hit" which first checks if the ball has hit any of the bricks from the list of bricks and then calculates which side of the brick hit it was and adjusts the bounce of the ball acordingly, also deletes the bricks that are hit, adds score to the player score for each brick destroyed and then prepares a new score to be drawn and checks if the new score is actually a high score, if the bricks list is empty(all the bricks have been destroyed) pauses the ball movement, increases the level,increases the stats in stats that need increasing with the level, spawns a new set of bricks which are now a smaller size and preperes the new level to be displayed.Than we have the "_ball_speed_adjust" that does some math as to how much speed we should add/subtract from the ball depending on where it was hit and finally we have the "_ball_lost" which reduces lives if we have any left and makes the ball to not be moving so the player can freely adjust the paddle wherever he sees fit before starting another run if not it stops the game indefinetly.And finally we have the block that runs the main function.
